import { invokeLambda, parseRows } from "@/backend/lambda/invokeLambda";
import inventoryItemRepository from "@/backend/repositories/items/inventoryItem/inventoryItemRepository";
import inventoryRepository from "@/backend/repositories/itemStore/inventory/inventoryRepository";
import userEventRepository from "@/backend/repositories/user/userEventRepository";
import { DailyLoginRewardFactory } from "@/models/events/dailyLogin/DailyLoginRewardFactory";
import { EventReward, EventRewardEntity, EventRewardInterface, EventRewardItemEntity } from "@/models/events/EventReward";
import { itemTemplateFactory } from "@/models/items/templates/models/ItemTemplateFactory";
import { InventoryItemList } from "@/models/itemStore/InventoryItemList";
import { UserEvent, UserEventEntity } from "@/models/user/userEvents/UserEvent";
import { getRandomInt } from "@/models/utility/RandomNumber";
import assert from "assert";
import { PoolClient } from "pg";
import { getInventoryEntity, updateGold } from "../../inventory/inventoryService";
import { transactionWrapper } from "../../utility/utility";
import { upsertInventoryItems } from "../../inventory/inventoryItem/inventoryItemService";
import User from "@/models/user/User";
import { v4 as uuidv4 } from 'uuid';
import eventRewardRepository from "@/backend/repositories/events/eventRewardRepository";
import eventRewardItemRepository from "@/backend/repositories/events/eventRewardItemRepository";

//TODO: Add EventReward and EventRewardItems to this

/**
 * Inserts a userEvent into the database. Does nothing if a userEvent with the same user and event_type already exists.
 * @param userEvent
 * @param client
 */
 export async function createUserEventInDatabase(userEvent: UserEvent, client?: PoolClient): Promise<boolean> {
	if (process.env.USE_DATABASE === 'LAMBDA') {
		try {
			const payload: any = {
				"queries": [
					{
						"tableName": "user_events",
						"columnsToWrite": [
							"id",
							"owner", 
							"event_type", 
							"streak",
							"created_at"
						],
						"values": [
							[
								userEvent.getId(),
								userEvent.getUser(),
								userEvent.getEventType(),
								userEvent.getStreak(),
								userEvent.getCreatedAt(),
							  ]
						],
						"conflictColumns": [], // Explicitly set to an empty array
						"returnColumns": [
							"id",
							"owner", 
							"event_type", 
							"streak",
							"created_at"
						]
					}
				]
			};

			let eventRewardQueries = [];
			let eventRewardItemQueries = [];

			if (userEvent.getEventReward()) {
				const eventReward = userEvent.getEventReward()!;
				eventRewardQueries.push(
					{
						"tableName": "event_rewards",
						"columnsToWrite": [
							"id",
							"owner",
							"inventory",
							"gold",
							"message"
						],
						"values": [
							[
								eventReward.getId(),
								userEvent.getId(),
								eventReward.getInventoryId(),
								eventReward.getGold(),
								eventReward.getMessage()
							]
						],
						"conflictColumns": [
							"owner"
						],
						"returnColumns": [
							"id",
							"owner"
						]
					}
				);
				// Moved eventRewardItemQueries declaration and population here to use returnedEventRewardId
			}

			const userEventInsertResult = await invokeLambda('garden-insert', payload);
			// Check if result is valid
			if (!userEventInsertResult) {
				throw new Error(`Error executing creation of userEvent with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
			}
			const userEventResult = parseRows<UserEventEntity[]>(userEventInsertResult[0]);

			// Check for discrepancies for userEvent
			if (userEventResult.length !== 1) {
				console.warn(`Expected 1 userEvent to be created, but got ${userEventResult.length}`);
			}
			// Update userEvent with the ID from the database, in case it was generated by the database
			const returnedId = userEventResult[0].id;
			userEvent.setId(returnedId);

			if (eventRewardQueries.length > 0) {
				const eventRewardInsertResult = await invokeLambda('garden-insert', { queries: eventRewardQueries });

				if (!eventRewardInsertResult) {
					throw new Error(`Error executing creation of eventReward with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
				}
				const eventRewardResult = parseRows<EventRewardEntity[]>(eventRewardInsertResult[0]);
				if (eventRewardResult.length !== 1) {
					console.warn(`Expected 1 eventReward to be created, but got ${eventRewardResult.length}`);
				}
				// Update eventReward with the ID from the database, in case it was generated by the database
				const returnedEventRewardId = eventRewardResult[0].id;
				userEvent.getEventReward()?.setId(returnedEventRewardId);

				const eventReward = userEvent.getEventReward()!;
				const rewardItems = eventReward.getItems().getAllItems();
				if (rewardItems.length > 0) {
					const itemValues = rewardItems.map(item => [
						uuidv4(), // Generate a new UUID for each reward item
						returnedEventRewardId, // Use the returned EventReward ID here
						item.itemData.id,
						item.getQuantity()
					]);
					eventRewardItemQueries.push(
						{
							"tableName": "event_reward_items",
							"columnsToWrite": [
								"id",
								"owner",
								"identifier",
								"quantity"
							],
							"values": itemValues,
							"conflictColumns": [
								"owner",
								"identifier"
							],
							"returnColumns": [
								"owner"
							]
						}
					);
				}

				if (eventRewardItemQueries.length > 0) {
					const eventRewardItemsInsertResult = await invokeLambda('garden-insert', { queries: eventRewardItemQueries });
					if (!eventRewardItemsInsertResult) {
						throw new Error(`Error executing creation of eventRewardItems with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
					}
					const eventRewardItemsResult = parseRows<EventRewardItemEntity[]>(eventRewardItemsInsertResult[0]);
					const rewardItemsFromEvent = userEvent.getEventReward()!.getItems().getAllItems();
					if (rewardItemsFromEvent.length > 0 && eventRewardItemsResult.length !== rewardItemsFromEvent.length) {
						console.warn(`Expected ${rewardItemsFromEvent.length} eventRewardItems to be created, but got ${eventRewardItemsResult.length}`);
					}
				}
			}
			return true;
		} catch (error) {
			console.error('Error creating userEvent from Lambda:', error);
			throw error;
		}
	} else {
		const userEventResult = await userEventRepository.createUserEvent(userEvent, client);
		if (!userEventResult) {
			throw new Error('There was an error creating the userEvent');
		}
		return true;
	}
}

/**
 * Updates the userEvent in the database, or creates new entries if they do not exist
 * Does not validate owner of user event
 * Overwrites the existing streak
 * @param userEvent
 * @param client
 */
 export async function upsertUserEventInDatabase(userEvent: UserEvent, client?: PoolClient): Promise<boolean> {
	if (process.env.USE_DATABASE === 'LAMBDA') {
		try {
			let userEventLambdaQuery: any;
			
			// If userEvent has an ID, we attempt to update it. Otherwise, create a new one.
			if (userEvent.getId()) {
				userEventLambdaQuery = {
					"tableName": "user_events",
					"columnsToWrite": [
						"id",
						"owner", 
						"event_type", 
						"streak",
						"created_at"
					],
					"values": [
						[
							userEvent.getId(),
							userEvent.getUser(),
							userEvent.getEventType(),
							userEvent.getStreak(),
							userEvent.getCreatedAt(),
						  ]
						],
						"conflictColumns": [], // Explicitly set to an empty array
						"returnColumns": [
							"id",
							"owner", 
							"event_type", 
							"streak",
							"created_at"
						]
					};
			} else {
				// For a new event, ensure a new UUID is generated
				const newId = uuidv4();
				userEvent.setId(newId);
				userEventLambdaQuery = {
					"tableName": "user_events",
					"columnsToWrite": [
						"id",
						"owner", 
						"event_type", 
						"streak",
						"created_at"
					],
					"values": [
						[
							userEvent.getId(),
							userEvent.getUser(),
							userEvent.getEventType(),
							userEvent.getStreak(),
							userEvent.getCreatedAt(),
						  ]
					],
					"returnColumns": [
						"id",
						"owner", 
						"event_type", 
						"streak",
						"created_at"
					]
				};
			}

			const userEventInsertResult = await invokeLambda('garden-insert', { queries: [userEventLambdaQuery] });
			// Check if result is valid
			if (!userEventInsertResult) {
				throw new Error(`Error executing upsert of userEvent with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
			}
			const userEventResult = parseRows<UserEventEntity[]>(userEventInsertResult[0]);
			// Check for discrepancies
			if (userEventResult.length !== 1) {
				console.warn(`Expected 1 userEvent to be upserted, but got ${userEventResult.length}`);
			}
			// Update userEvent with the ID from the database, in case it was generated by the database
			const returnedId = userEventResult[0].id;
			userEvent.setId(returnedId);

			let eventRewardItemQueries = []; // Declare here to be in scope for later use

			let eventRewardQueries = [];
			if (userEvent.getEventReward()) {
				const eventReward = userEvent.getEventReward()!;
				eventRewardQueries.push(
					{
						"tableName": "event_rewards",
						"columnsToWrite": [
							"id",
							"owner",
							"inventory",
							"gold",
							"message"
						],
						"values": [
							[
								eventReward.getId(),
								userEvent.getId(),
								eventReward.getInventoryId(),
								eventReward.getGold(),
								eventReward.getMessage()
							]
						],
						"conflictColumns": [
							"owner"
						],
						"updateQuery": {
							"values": {
								"inventory": {"excluded": true},
								"gold": {"excluded": true},
								"message": {"excluded": true}
							},
							"conditions": {}
						},
						"returnColumns": [
							"id",
							"owner"
						]
					}
				);

				const rewardItems = eventReward.getItems().getAllItems();
				// Moved eventRewardItemQueries declaration and population here to use returnedEventRewardId
			}

			if (eventRewardQueries.length > 0) {
				const eventRewardInsertResult = await invokeLambda('garden-insert', { queries: eventRewardQueries });

				if (!eventRewardInsertResult) {
					throw new Error(`Error executing upsert of eventReward with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
				}
				const eventRewardResult = parseRows<EventRewardEntity[]>(eventRewardInsertResult[0]);
				if (eventRewardResult.length !== 1) {
					console.warn(`Expected 1 eventReward to be upserted, but got ${eventRewardResult.length}`);
				}
				// Update eventReward with the ID from the database, in case it was generated by the database
				const returnedEventRewardId = eventRewardResult[0].id;
				userEvent.getEventReward()?.setId(returnedEventRewardId);

				const rewardItems = userEvent.getEventReward()!.getItems().getAllItems();
				if (rewardItems.length > 0) {
					const itemValues = rewardItems.map(item => [
						uuidv4(), // Generate a new UUID for each reward item
						returnedEventRewardId, // Use the returned EventReward ID here
						item.itemData.id,
						item.getQuantity()
					]);
					eventRewardItemQueries.push(
						{
							"tableName": "event_reward_items",
							"columnsToWrite": [
								"id",
								"owner",
								"identifier",
								"quantity"
							],
							"values": itemValues,
							"conflictColumns": [
								"owner",
								"identifier"
							],
							"returnColumns": [
								"owner"
							]
						}
					);
				}

				if (eventRewardItemQueries.length > 0) {
					// Removed the loop to update owner, as it's now set during construction
					const eventRewardItemsInsertResult = await invokeLambda('garden-insert', { queries: eventRewardItemQueries });
					if (!eventRewardItemsInsertResult) {
						throw new Error(`Error executing upsert of eventRewardItems with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
					}
					const eventRewardItemsResult = parseRows<EventRewardItemEntity[]>(eventRewardItemsInsertResult[0]);
					const rewardItemsFromEvent = userEvent.getEventReward()!.getItems().getAllItems(); // Renamed to avoid conflict
					if (rewardItemsFromEvent.length > 0 && eventRewardItemsResult.length !== rewardItemsFromEvent.length) {
						console.warn(`Expected ${rewardItemsFromEvent.length} eventRewardItems to be upserted, but got ${eventRewardItemsResult.length}`);
					}
				}
			}
			return true;
		} catch (error) {
			console.error('Error upserting userEvent from Lambda:', error);
			throw error;
		}
	} else {
		const userEventResult = await userEventRepository.createOrUpdateUserEvent(userEvent, client);
		if (!userEventResult) {
			throw new Error('There was an error upserting the userEvent');
		}
		return true;
	}
}

/**
 * @returns a userEventEntity, or null
 */
 export async function getUserEventEntityByUserIdAndEventType(userEvent: UserEvent, client?: PoolClient): Promise<UserEventEntity | null> {
	if (process.env.USE_DATABASE === 'LAMBDA') {
		try {
			// Call Lambda function with userEvent as payload
			//SELECT * FROM users WHERE id = $1
			const payload = {
				"queries": [
					{
						"returnColumns": [
							"id",
							"owner", 
							"event_type", 
							"streak",
							"created_at"
						],
						"tableName": "user_events",
						"conditions": {
							"owner": {
								"operator": "=",
								"value": userEvent.getUser()
							},
							"event_type": {
								"operator": "=",
								"value": userEvent.getEventType()
							}
						},
						"orderBy": [
							{"column": "created_at", "direction": "DESC"}
						],
						"limit": 1
					}
				]
			  }
			const userEventResult = await invokeLambda('garden-select', payload);
			// Check if result is valid
			if (!userEventResult) {
				throw new Error(`Could not select userEvent with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
			}
			const userEventEntityResult = parseRows<UserEventEntity[]>(userEventResult[0]);
			if (userEventEntityResult.length > 1) {
				console.warn(`Expected 1 userEvent to be fetched, but got ${userEventResult.length}`);
			}
			if (userEventEntityResult.length == 0) return null;
			assert(userEventRepository.validateUserEventEntity(userEventEntityResult[0]));
			return userEventEntityResult[0];
		} catch (error) {
			console.error('Error fetching userEventEntity from Lambda:', error);
			throw error;
		}
	} else {
		const innerFunction = async (client: PoolClient) => {
			//Create user
			const userEventResult = await userEventRepository.getUserEvent(userEvent.getUser(), userEvent.getEventType());
			// Check if result is valid
			if (!userEventResult) {
				throw new Error(`Could not find userEvent with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
			}
			return userEventResult;
		}
		// Call transactionWrapper with inner function and description
		return transactionWrapper(innerFunction, 'fetchUserEventEntityFromDatabase', client);
	}
}

/**
 * @returns a userEvent, or null
 */
export async function getUserEventFromDatabase(userEvent: UserEvent, client?: PoolClient): Promise<UserEvent | null> {
	if (process.env.USE_DATABASE === 'LAMBDA') {
		try {
			// Call Lambda function with userEvent as payload
			//SELECT * FROM users WHERE id = $1
			const payload: any = {
				"queries": [
					{
						"returnColumns": [
							"id",
							"owner", 
							"event_type", 
							"streak",
							"created_at"
						],
						"tableName": "user_events",
						"conditions": {
							"owner": {
								"operator": "=",
								"value": userEvent.getUser()
							},
							"event_type": {
								"operator": "=",
								"value": userEvent.getEventType()
							}
						},
						"orderBy": [
							{"column": "created_at", "direction": "DESC"}
						],
						"limit": 1
					}
				]
			  };

			if (userEvent.getEventReward()) {
				payload.queries.push(
					{
						"returnColumns": [
							"id",
							"owner",
							"inventory",
							"gold",
							"message"
						],
						"tableName": "event_rewards",
						"conditions": {
							"owner": {
								"operator": "=",
								"value": userEvent.getId()
							}
						}
					}
				);
			}

			const userEventResult = await invokeLambda('garden-select', payload);
			// Check if result is valid
			if (!userEventResult) {
				throw new Error(`Could not select userEvent with owner: ${userEvent.getUser()} and event type: ${userEvent.getEventType()}`);
			}
			const userEventEntityResult = parseRows<UserEventEntity[]>(userEventResult[0]);
			if (userEventEntityResult.length > 1) {
				console.warn(`Expected 1 userEvent to be fetched, but got ${userEventEntityResult.length}`);
			}
			if (userEventEntityResult.length == 0) return null;

			assert(userEventRepository.validateUserEventEntity(userEventEntityResult[0]));
			
			let eventRewardEntity: EventRewardEntity | undefined;
			if (userEvent.getEventReward() && userEventResult[1]) {
				const eventRewardResult = parseRows<EventRewardEntity[]>(userEventResult[1]);
				if (eventRewardResult.length > 1) {
					console.warn(`Expected 1 eventReward to be fetched, but got ${eventRewardResult.length}`);
				}
				if (eventRewardResult.length > 0) {
					eventRewardEntity = eventRewardResult[0];

					// Now fetch event reward items
					const itemPayload = {
						"queries": [
							{
								"returnColumns": [
									"id",
									"owner",
									"identifier",
									"quantity"
								],
								"tableName": "event_reward_items",
								"conditions": {
									"owner": {
										"operator": "=",
										"value": eventRewardEntity.id
									}
								}
							}
						]
					};
					const eventRewardItemResult = await invokeLambda('garden-select', itemPayload);
					if (!eventRewardItemResult) {
						throw new Error(`Could not select eventRewardItems for eventRewardId: ${eventRewardEntity.id}`);
					}
					const eventRewardItemEntities = parseRows<EventRewardItemEntity[]>(eventRewardItemResult[0]);
					
					const rewardItems = eventRewardItemRepository.makeEventRewardItemObjectBatch(eventRewardItemEntities);
					
					const userEventInstance = userEventRepository.makeUserEventObject(userEventEntityResult[0], eventRewardEntity, rewardItems);
					return userEventInstance;
				}
			}
			return userEventRepository.makeUserEventObject(userEventEntityResult[0]);
		} catch (error) {
			console.error('Error fetching userEvent from Lambda:', error);
			throw error;
		}
	} else {
		throw new Error(`This is not implemented yet!`);
	}
}

/**
 * @returns a userEventEntity, or null
 */
export async function getUserEventEntityById(id: string, client?: PoolClient): Promise<UserEventEntity | null> {
	if (process.env.USE_DATABASE === 'LAMBDA') {
		try {
			const payload = {
				"queries": [
					{
						"returnColumns": [
							"id",
							"owner", 
							"event_type", 
							"streak",
							"created_at"
						],
						"tableName": "user_events",
						"conditions": {
							"id": {
								"operator": "=",
								"value": id
							}
						}
					}
				]
			  }
			const userEventResult = await invokeLambda('garden-select', payload);
			// Check if result is valid
			if (!userEventResult) {
				throw new Error(`Could not select userEvent with id: ${id}`);
			}
			const userEventEntityResult = parseRows<UserEventEntity[]>(userEventResult[0]);
			if (userEventEntityResult.length > 1) {
				console.warn(`Expected 1 userEvent to be fetched, but got ${userEventResult.length}`);
			}
			if (userEventEntityResult.length == 0) return null;
			assert(userEventRepository.validateUserEventEntity(userEventEntityResult[0]));
			return userEventEntityResult[0];
		} catch (error) {
			console.error('Error fetching userEventEntity from Lambda:', error);
			throw error;
		}
	} else {
		throw new Error(`This is not implemented yet!`);
	}
}

export async function claimDailyReward(userId: string, inventoryId: string, client?: PoolClient): Promise<EventRewardInterface> {
	const currentTime = Date.now();
	if (process.env.USE_DATABASE === 'LAMBDA') {
		try {
			let rewardGold = 0;
			let rewardMessage = '';
			let inventoryEntity = await getInventoryEntity(inventoryId, userId, client);
			let eventEntity = await getUserEventEntityByUserIdAndEventType(new UserEvent(uuidv4(), inventoryEntity.owner, "DAILYLOGIN"));
			let eventInstance: UserEvent;
			if (eventEntity) {
				eventInstance = userEventRepository.makeUserEventObject(eventEntity);
			} else {
				eventInstance = new UserEvent(uuidv4(), inventoryEntity.owner, "DAILYLOGIN");
			}
			if (eventEntity) {
				// If the event already existed, check that it was at least 1 day ago
				const canClaimReward = DailyLoginRewardFactory.canClaimReward(new Date(currentTime), eventInstance);
				
				if (!canClaimReward) {
					const msRemaining = DailyLoginRewardFactory.getDefaultTimeBetweenRewards();
			  
					// Break down into hours, minutes, seconds
					const hours = Math.floor(msRemaining / (1000 * 60 * 60));
					const minutes = Math.floor((msRemaining % (1000 * 60 * 60)) / (1000 * 60));
					const seconds = Math.floor((msRemaining % (1000 * 60)) / 1000);
			  
					throw new Error(
						`Daily login reward is not ready. Try again in ${hours}h ${minutes}m ${seconds}s`
					);
				}
			}

			let newStreak = 1; // Default to 1 for the first login
			if (eventEntity) {
				newStreak = eventInstance.getStreak() + 1;
			}

			// Create a brand new UserEvent instance for the new record
			const newEventInstance = new UserEvent(uuidv4(), inventoryEntity.owner, "DAILYLOGIN");
			newEventInstance.setStreak(newStreak);
			newEventInstance.setCreatedAt(new Date(Date.now())); // Changed from setLastOccurence to setCreatedAt
			
			const dailyLoginRewardGenerator = new DailyLoginRewardFactory(newStreak);
			rewardGold = DailyLoginRewardFactory.getDefaultGoldReward(newStreak);
			const rewardBucket: EventReward = dailyLoginRewardGenerator.createRewardBucket(inventoryEntity.owner, inventoryEntity.id, newStreak, rewardGold, rewardMessage);

			const rewardItems: InventoryItemList = rewardBucket.getItems();
			newEventInstance.setEventReward(rewardBucket);
			await upsertInventoryItems(inventoryEntity.id, inventoryEntity.owner, rewardItems, client);
			await createUserEventInDatabase(newEventInstance, client);
			await updateGold(inventoryEntity.id, inventoryEntity.owner, rewardGold, false, client);

			let reward: EventRewardInterface = {
				id: newEventInstance.getId(),
				eventType: newEventInstance.getEventType(),
				userId: rewardBucket.getUserId(),
				inventoryId: rewardBucket.getInventoryId(),
				streak: rewardBucket.getStreak(),
				items: rewardBucket.getItems().toPlainObject(),
				gold: rewardBucket.getGold(),
				message: rewardBucket.getMessage()
			};
			return reward;
		} catch (error) {
			console.error('Error fetching userEventEntity from Lambda:', error);
			throw error;
		}
	} else {
		let items = new InventoryItemList();
		let rewardGold = 0;
		let rewardMessage = '';
		let eventEntity = await userEventRepository.getUserEvent(userId, "DAILYLOGIN");
		let eventInstance: UserEvent;
		if (eventEntity) {
			eventInstance = userEventRepository.makeUserEventObject(eventEntity);
		} else {
			eventInstance = new UserEvent(uuidv4(), userId, "DAILYLOGIN");
		}
		
		if (eventEntity) {
			const now = new Date();
			const eventInstanceForCheck = userEventRepository.makeUserEventObject(eventEntity);
			const canClaimReward = DailyLoginRewardFactory.canClaimReward(now, eventInstanceForCheck);

			if (!canClaimReward) {
				const msRemaining = DailyLoginRewardFactory.getDefaultTimeBetweenRewards();

				// Break down into hours, minutes, seconds
				const hours = Math.floor(msRemaining / (1000 * 60 * 60));
				const minutes = Math.floor((msRemaining % (1000 * 60 * 60)) / (1000 * 60));
				const seconds = Math.floor((msRemaining % (1000 * 60)) / 1000);

				throw new Error(
					`Daily login reward is not ready. Try again in ${hours}h ${minutes}m ${seconds}s`
				);
			}
		}
		
		eventInstance.setStreak(eventInstance.getStreak() + 1);
		eventInstance.setCreatedAt(new Date(Date.now())); // Changed from setLastOccurence
		let streak = eventInstance.getStreak();
		rewardGold = Math.min(10, streak) * 50 + getRandomInt(1, 50);

		// TODO: Replace with reward bucket
		const appleSeedTemplate = itemTemplateFactory.getInventoryItemTemplateByName("apple seed");
		assert(appleSeedTemplate);
		items.addItem(appleSeedTemplate, 100);
		await userEventRepository.createOrUpdateUserEvent(eventInstance, client);
		await inventoryRepository.updateInventoryGold(inventoryId, rewardGold, client);
		await inventoryItemRepository.addInventoryItem(inventoryId, items.getAllItems()[0], client);

		let reward: EventRewardInterface = {
			id: eventInstance.getId(),
			eventType: eventInstance.getEventType(),
			userId: userId,
			inventoryId: inventoryId,
			streak: eventInstance.getStreak(),
			items: items.toPlainObject(),
			gold: rewardGold,
			message: rewardMessage
		};
		return reward;
	}
}